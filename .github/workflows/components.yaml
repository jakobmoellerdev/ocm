name: component CTFs

on:
  pull_request:
  workflow_call:
  push:
    branches:
      - main

permissions:
  contents: read
  pull-requests: read

env:
  CTF_TYPE: tgz

jobs:
  build:
    name: "Build"
    strategy:
      matrix:
        component: [ocmcli]
#        component: [ocmcli, helminstaller, helmdemo, subchartsdemo, ecrplugin]
    runs-on: large_runner
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: '${{ github.workspace }}/go.mod'
          cache: false
      - name: Get go environment for use with cache
        run: |
          echo "go_cache=$(go env GOCACHE)" >> $GITHUB_ENV
          echo "go_modcache=$(go env GOMODCACHE)" >> $GITHUB_ENV
      # This step will only reuse the go mod and build cache from main made during the Build,
      # see push_ocm.yaml => "ocm-cli-latest" Job
      # This means it never caches by itself and PRs cannot cause cache pollution / thrashing
      # This is because we have huge storage requirements for our cache because of the mass of dependencies
      - name: Restore / Reuse Cache from central build
        id: cache-golang-restore
        uses: actions/cache/restore@v4 # Only Restore, not build another cache (too big)
        with:
          path: |
            ${{ env.go_cache }}
            ${{ env.go_modcache }}
          key: ${{ env.cache_name }}-${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/go.mod') }}
          restore-keys: |
            ${{ env.cache_name }}-${{ runner.os }}-go-
        env:
          cache_name: ocm-cli-latest-go-cache # needs to be the same key in the end as in the build step
      - name: CTF
        run: |
          cd components/${{ matrix.component }}
          PATH=$PATH:$(go env GOPATH)/bin CTF_TYPE=${{ env.CTF_TYPE }} make ctf descriptor describe
      - name: Upload CTF on main
        uses: actions/upload-artifact@v4
        with:
          compression-level: '0' # we already compress ourselves
          if-no-files-found: error
          overwrite: true
          retention-days: 1
          name: ctf-${{ matrix.component }}
          path: gen/${{ matrix.component }}/ctf

  aggregate:
    name: "Aggregate Build Artifacts"
    runs-on: ubuntu-latest
    needs: build
    env:
      components: ocmcli
#      components: ocmcli helminstaller helmdemo subchartsdemo ecrplugin
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: '${{ github.workspace }}/go.mod'
          cache: false
      - name: Get go environment for use with cache
        run: |
          echo "go_cache=$(go env GOCACHE)" >> $GITHUB_ENV
          echo "go_modcache=$(go env GOMODCACHE)" >> $GITHUB_ENV
      # This step will only reuse the go mod and build cache from main made during the Build,
      # see push_ocm.yaml => "ocm-cli-latest" Job
      # This means it never caches by itself and PRs cannot cause cache pollution / thrashing
      # This is because we have huge storage requirements for our cache because of the mass of dependencies
      - name: Restore / Reuse Cache from central build
        id: cache-golang-restore
        uses: actions/cache/restore@v4 # Only Restore, not build another cache (too big)
        with:
          path: |
            ${{ env.go_cache }}
            ${{ env.go_modcache }}
          key: ${{ env.cache_name }}-${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/go.mod') }}
          restore-keys: |
            ${{ env.cache_name }}-${{ runner.os }}-go-
        env:
          cache_name: ocm-cli-latest-go-cache # needs to be the same key in the end as in the build step
      - name: Download CTFs
        uses: actions/download-artifact@v4
        with:
          pattern: 'ctf-*'
          path: gen/downloaded-ctfs
      - name: Move CTFs into correct directory for aggregation
        run: |
          IFS=" " read -a COMPONENTS <<< ${{ env.components }}
          for i in "${COMPONENTS[@]}"; do
            mkdir -p ${{ github.workspace }}/gen/${i}
            mv ${{ github.workspace }}/gen/downloaded-ctfs/ctf-${i} ${{ github.workspace }}/gen/${i}/ctf
          done
      - name: Create aggregated CTF
        run: |
          PATH=$PATH:$(go env GOPATH)/bin CTF_TYPE=${{ env.CTF_TYPE }} COMPONENTS=${{ env.components }} make plain-ctf
      - name: Upload aggregated CTF
        # only update on main
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          compression-level: '0' # we already compress ourselves
          if-no-files-found: error
          overwrite: true
          retention-days: 1
          name: ctf-aggregated
          path: gen/ctf
      - name: Delete old CTFs that lead up to aggregation
        uses: geekyeggo/delete-artifact@v5
        with:
          name: |
            ctf-*